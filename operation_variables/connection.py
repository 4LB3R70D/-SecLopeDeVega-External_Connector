"""
Copyright 2022 The Sec Lope De Vega Authors. All rights reserved.

This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this file,
You can obtain one at http://mozilla.org/MPL/2.0/.

=================================================
Sec Lope De Vega external connector
=================================================
Module: connection.py
Author: Alberto Dominguez 

This module contains code related to the main logic about the connection logic object
used to manage the connections established between external parties and the external connector
"""
import copy
import logging
import time
from enum import Enum

from utils import connection_utils, interoperability_py_go

# logger
logger = logging.getLogger(__name__)

# ==========================================================================================
# CONNECTION OBJECT
# ==========================================================================================

# Enums for connection register values


class ConnectionStatus(Enum):
    OPEN = "OPEN"
    CLOSE = "CLOSE"
    TIMED_OUT = "TIMED_OUT"
    RECONNECTING = "RECONNECTING"


class Connection:
    '''
    Object to manage the 'connection' concept
    '''

    def __init__(self, id_conn, source_ip, source_port, mem_variables, starting_time, last_interaction, status, client_mode,
                 session_enable, session_key, session_key_value_separator, session_end_value, session_value_autogenerated,
                 session_value_numb_chars, session_value_type_chars, encoding, port_as_identifier, session_value=None,
                 connection_socket=None, client_socket_id=None):

        self.id = id_conn
        self.ip = source_ip
        self.port = source_port
        self.status = status
        self.client_mode = client_mode
        self.port_as_identifier = port_as_identifier
        self.connection_socket = connection_socket
        self.client_socket_id = client_socket_id
        # Greetings flag to detect if the greetings messages has ben sent or not
        self.greetings_sent = False
        # Encoding
        self.encoding = connection_utils.switcher_encoding.get(
            encoding.lower(), connection_utils.UTF_8)
        # Conversation rules memory
        self.memory = connection_utils.aux_conv_rules_memory_init(
            mem_variables, id_conn)
        # Timing
        self.starting_time = starting_time
        self.last_interaction = last_interaction
        self.ending_time = None
        # Flag to indicate when the sync conversation rules are exectued in the
        # context of TCP and closing the TCP socket after answering, but there are async
        # rules still in execution ==> So, no more sync rules rules should be executed
        self.sync_done_async_in_progress = False
        # This subflag tells when the async part is already done
        self.sync_done_async_done = False

        # ----------------------------
        # session elements
        # ----------------------------
        if interoperability_py_go.interlanguage_bool_check(session_enable):
            self.session_enable = True
        else:
            self.session_enable = False

        self.session_key = session_key
        self.session_key_value_separator = session_key_value_separator
        self.session_end_value = session_end_value
        self.session_value_type_chars = session_value_type_chars
        self.session_value_numb_chars = session_value_numb_chars

        if self.session_enable and session_value_autogenerated and (not client_mode):
            self.session_value = connection_utils.get_autogenerated_token(
                session_value_type_chars, session_value_numb_chars)
            logger.info(
                f"New session ID:'{self.session_value}' created for the connection:{id_conn}")
        else:
            self.session_value = session_value

    def do_copy(self):
        '''
        Wrapper method to create a copy of a connection
        https://docs.python.org/3/library/copy.html
        '''
        conn_copy = copy.copy(self)
        return conn_copy

    def touch(self):
        '''
        Method to update the last interaction field of a connection
        '''
        self.last_interaction = time.time()
        logger.debug(
            f"Last interaction field updated for the connection:{self.id}")

    def timeout(self):
        '''
        Method to timeout a connection. This is a temporary status to be ended when the 
        connection is finally closed
        '''
        self.status = ConnectionStatus.TIMED_OUT
        self.ending_time = time.time()
        logger.info(f"Connection:{self.id} has been timed out")

    def close(self):
        '''
        Method to clod an active connection
        '''
        self.status = ConnectionStatus.CLOSE
        self.ending_time = time.time()
        logger.info(f"Connection:{self.id} has been closed")

    def check_status(self):
        '''
        Method to check the status of a given connection
        '''
        self.touch()
        return self.status

    def mark_reconnecting_status(self):
        '''
        Method to mark a connection as in reconnecting status
        '''
        self.status = ConnectionStatus.RECONNECTING
        logger.debug(f"Connection:{self.id} mark as 'RECONNECTING'")

    def unmark_reconnecting_status(self):
        '''
        Method to unmark a connection as in reconnecting status
        '''
        self.status = ConnectionStatus.OPEN
        logger.debug(
            f"Connection:{self.id} mark again as 'OPEN' after the reconnection")

    def update_memory(self, mem_var_name, mem_var_new_value):
        '''
        Method to update a given memory variable of a connection
        '''
        self.touch()

        # variable to return
        success = False

        if mem_var_name in self.memory:
            self.memory[mem_var_name] = mem_var_new_value
            success = True
            logger.info(f"Memory variable '{mem_var_name}' in the connection:{self.id} updated. " +
                        f"New value: '{mem_var_new_value}'")
        else:
            logger.warning(
                f"Not found the memory variable '{mem_var_name}' in the connection:{self.id}")

        return success

    def get_connection_socket(self):
        '''
        Method to get the connection socket (if any)
        '''
        return self.connection_socket

    def update_session_id(self, new_session_value):
        '''
        Method to update a session ID of the connection
        '''
        self.session_value = new_session_value
        logger.info(f"Updated the session value for the connection:{self.id}." +
                    f"New value: {new_session_value}")

    def update_connection_socket_and_port(self, new_socket, new_port):
        '''
        Method to update the connection socket of the connection
        '''
        self.connection_socket = new_socket
        if new_port is not None:
            self.port = new_port
            logger.info(
                f"Updated the TCP connection socket and port for the connection:{self.id}")
        else:
            logger.info(
                f"Updated the TCP connection socket for the connection:{self.id}")

    def enable_sync_done_async_in_progress_flag(self):
        '''
        Method to enable the flag 'sync_done_async_in_progress' of the connection. This flag indicates
        when the sync conversation rules are exectued in the context of TCP and closing the TCP socket 
        after answering, but there are async rules still in execution ==> So, no more sync rules rules 
        should be executed
        '''
        self.sync_done_async_in_progress = True
        self.sync_done_async_done = False

    def disable_sync_done_async_in_progress_flag(self):
        '''
        Method to disable the flag 'sync_done_async_in_progress' of the connection. This flag indicates
        when the sync conversation rules are exectued in the context of TCP and closing the TCP socket 
        after answering, but there are async rules still in execution ==> So, no more sync rules rules 
        should be executed
        '''
        self.sync_done_async_in_progress = False
        self.sync_done_async_done = True

    def check_sync_done_async_in_progress_flag(self):
        '''
        Method to check the flag 'sync_done_async_in_progress' and subflag 'sync_done_async_done' of the connection. 
        This flag indicates when the sync conversation rules are exectued in the context of TCP and closing the 
        TCP socket after answering, but there are async rules still in execution ==> So, no more sync rules rules 
        should be executed
        '''
        return self.sync_done_async_in_progress and not self.sync_done_async_done

    def reset_sync_done_async_in_progress_flag(self):
        '''
        Method to rest the flag 'sync_done_async_in_progress' and subflag 'sync_done_async_done of the connection. 
        This flag indicates when the sync conversation rules are exectued in the context of TCP and closing the 
        TCP socket after answering, but there are async rules still in execution ==> So, no more sync rules rules 
        should be executed
        '''
        self.sync_done_async_in_progress = False
        self.sync_done_async_done = False
